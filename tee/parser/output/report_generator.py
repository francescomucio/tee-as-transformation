"""
Report generation functionality for dependency graphs.
"""

import logging
from pathlib import Path

from tee.parser.shared.constants import OUTPUT_FILES
from tee.parser.shared.exceptions import OutputGenerationError
from tee.parser.shared.types import DependencyGraph, ParsedFunction

from .markdown_report_builder import (
    build_circular_dependencies_section,
    build_execution_order_section,
    build_statistics_section,
    build_test_details_section,
    build_transformation_details_section,
    separate_nodes_by_type,
)
from .visualizer import DependencyVisualizer

# Configure logging
logger = logging.getLogger(__name__)


class ReportGenerator:
    """Handles generation of markdown reports with Mermaid diagrams."""

    def __init__(self, output_folder: Path):
        """
        Initialize the report generator.

        Args:
            output_folder: Path to the output folder
        """
        self.output_folder = output_folder
        self.output_folder.mkdir(parents=True, exist_ok=True)
        self.visualizer = DependencyVisualizer()

    def generate_markdown_report(
        self, graph: DependencyGraph, output_file: str | None = None, parsed_functions: dict[str, ParsedFunction] | None = None
    ) -> Path:
        """
        Generate a comprehensive markdown report with Mermaid diagram.

        Args:
            graph: The dependency graph
            output_file: Optional custom output file path
            parsed_functions: Optional dict of parsed functions to identify function nodes

        Returns:
            Path to the generated report

        Raises:
            OutputGenerationError: If report generation fails
        """
        try:
            if output_file is None:
                output_file = self.output_folder / OUTPUT_FILES["markdown_report"]
            else:
                output_file = Path(output_file)

            # Ensure output directory exists
            output_file.parent.mkdir(parents=True, exist_ok=True)

            parsed_functions = parsed_functions or {}
            function_names = set(parsed_functions.keys())
            
            mermaid_diagram = self.visualizer.generate_mermaid_diagram(graph, parsed_functions)

            # Separate nodes by type
            test_nodes, function_nodes, table_nodes = separate_nodes_by_type(
                graph["nodes"], function_names
            )

            # Build markdown report sections
            markdown_content = """# Dependency Graph Report

## Overview

This report provides a comprehensive analysis of the SQL model dependencies.

"""
            
            # Statistics section
            markdown_content += build_statistics_section(
                table_nodes, function_nodes, test_nodes, graph
            )
            
            # Visual diagram section
            markdown_content += f"""## Visual Diagram

```mermaid
{mermaid_diagram}
```

"""
            
            # Execution order section
            markdown_content += build_execution_order_section(graph["execution_order"])
            
            # Tests details section
            markdown_content += build_test_details_section(test_nodes, graph)
            
            # Transformation details section
            markdown_content += build_transformation_details_section(
                function_nodes, table_nodes, function_names, graph
            )
            
            # Circular dependencies section
            markdown_content += build_circular_dependencies_section(graph["cycles"])
            
            # Footer
            markdown_content += "---\n\n*Generated by Project Parser*"

            with open(output_file, "w", encoding="utf-8") as f:
                f.write(markdown_content)

            logger.info(f"Markdown report saved to {output_file}")
            print(f"Markdown report saved to {output_file}")
            print(f"Includes Mermaid diagram and detailed analysis")

            return output_file

        except Exception as e:
            raise OutputGenerationError(f"Failed to generate markdown report: {e}") from e

    def generate_mermaid_diagram(
        self, graph: DependencyGraph, output_file: str | None = None, parsed_functions: dict[str, ParsedFunction] | None = None
    ) -> Path:
        """
        Generate a standalone Mermaid diagram file.

        Args:
            graph: The dependency graph
            output_file: Optional custom output file path

        Returns:
            Path to the generated Mermaid file

        Raises:
            OutputGenerationError: If diagram generation fails
        """
        try:
            if output_file is None:
                output_file = self.output_folder / OUTPUT_FILES["mermaid_diagram"]
            else:
                output_file = Path(output_file)

            # Use the visualizer to save the Mermaid diagram
            self.visualizer.save_mermaid_diagram(graph, str(output_file), parsed_functions=parsed_functions)

            return output_file

        except Exception as e:
            raise OutputGenerationError(f"Failed to generate Mermaid diagram: {e}") from e

    def generate_all_reports(self, graph: DependencyGraph, parsed_functions: dict[str, ParsedFunction] | None = None) -> dict[str, Path]:
        """
        Generate all available reports.

        Args:
            graph: The dependency graph
            parsed_functions: Optional dict of parsed functions to identify function nodes

        Returns:
            Dict mapping report type to file path

        Raises:
            OutputGenerationError: If report generation fails
        """
        try:
            results = {}

            # Generate markdown report
            results["markdown_report"] = self.generate_markdown_report(graph, parsed_functions=parsed_functions)

            # Generate Mermaid diagram
            results["mermaid_diagram"] = self.generate_mermaid_diagram(graph, parsed_functions=parsed_functions)

            return results

        except Exception as e:
            raise OutputGenerationError(f"Failed to generate all reports: {e}") from e
